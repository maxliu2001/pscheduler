#!/usr/bin/env python3

#
# Development Order #5:
#
# This is the meat and bones of the tool, where the actual desired
# commands or operation will be run. The results are then recorded
# and added to the 'results' JSON data, which will then be sent
# back to the test. Both system and api are able to be used here.
#

import datetime
import subprocess
import json
import sys
import time
import os
import pscheduler
import tempfile

#error and diagnostic tracking
error = ''
diags = ''
authenticated = False
need_root = False

#declare local variables
interface = ''
path = ''
username = ''
password = ''
driver = ''
ssid = ''
bssid = ''
key_managment = ''
timeout = 4000

# from stdin
input = pscheduler.json_load(exit_on_error=True)

# Take input from test spec
try:
    interface = input['test']['spec']['interface']

except KeyError:
    pscheduler.fail('Missing the interface in input')

try:
    username = input['test']['spec']['_username']
except KeyError:
    diags += "Proceeding without a username"

try:
    password = input['test']['spec']['_password']
except KeyError:
    diags += "Proceeding without a password"

try:
    driver = input['test']['spec']['driver']
except KeyError:
    diags += "Proceeding without a driver"

try:
    ssid = input['test']['spec']['ssid']
except KeyError:
    diags += "Proceeding without a ssid"

try:
    bssid = input['test']['spec']['bssid']
except KeyError:
    diags += "Proceeding without a bssid"

try:
    key_management = input['test']['spec']['key-management']
except KeyError:
    diags += "Proceeding without key_management"

try:
    driver = input['test']['spec']['driver']
except KeyError:
    diags += "proceeding with default driver"


timeout_iso = input['test']['spec'].get('timeout', 'PT10S')
timeout = pscheduler.timedelta_as_seconds( pscheduler.iso8601_as_timedelta(timeout_iso) )
succeeded = False

WPA_CONFIG_PATH = '/tmp/wpa_supplicant.conf'
dir_path = os.path.dirname(WPA_CONFIG_PATH)
WPA_CTRL_IFACE_BASE = '/var/run/wpa_supplicant'

wpa_status = ["sudo", "wpa_cli", "status"]
status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
# print(status)

if status:
    # create config file and start wpa_supplicant
    # print('create new interface')
    # if not os.path.exists(dir_path):
    #    status, out, err = pscheduler.run_program(['sudo','mkdir',WPA_CONFIG_PATH])
    #    if status:
    #     pscheduler.succeed_json( {
    #        'succeeded': False,
    #        'diags': '' + out,
    #        'error': 'failed to create dir for interface: ' + err,
    #        'result': None
    #        })
    #    else:
    #        diags += "created new interface dir\n"

    with open(WPA_CONFIG_PATH, 'w') as f:
        f.write('ctrl_interface='+WPA_CTRL_IFACE_BASE+'\r\n')
        f.write('update_config=1\r\n')
        f.write('p2p_disabled=1\r\n')
    status, out, err = pscheduler.run_program(['sudo','wpa_supplicant','-Dnl80211','-B','-i',interface,'-c',WPA_CONFIG_PATH])
    if status:
         pscheduler.succeed_json( {
            'succeeded': False,
            'diags': '' + out,
            'error': 'failed to initialize interface: ' + err,
            'result': None
            })
    else:
        diags += out
# print('initalize interface')
temp = open(WPA_CONFIG_PATH,'w')
temp.writelines(['ctrl_interface=DIR=/var/run/wpa_supplicant\n', 'update_config=1\n', 'country=US\n', 'p2p_disabled=1\n',  'network={\n'])
if ssid != '':
    temp.write('ssid="{}"\n'.format(ssid))
temp.write('scan_ssid=1\n')
if bssid != '':
    temp.write('bssid={}\n'.format(bssid))
if key_management != '':
   temp.write('key_mgmt={}\n'.format(key_management))
if username != '':
    temp.write('identity="{}"\n'.format(username))
if password != '':
    temp.write('password="{}"\n'.format(password))
temp.write('eap=PEAP\n')
temp.write('phase1="peaplabel=0"\n')
temp.write('phase2="auth=MSCHAPV2"\n')
temp.write('}\n')
temp.close()

start_time = datetime.datetime.now()
wpa_auth = ['sudo', 'wpa_cli', '-i', interface, 'reconfigure']
status, stdout, stderr = pscheduler.run_program(wpa_auth, timeout=timeout)
wpa_status = ["sudo", "wpa_cli", "status"]
status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
if status != 0:
    error += 'Error returned: \n%s' % stderr.strip('\n')
    succeeded = False
    fail_json = { 'succeeded': succeeded,
              'error': 'failed to run wpa_cli to validate the authentication',
              'diags': diags }
    
    succeeded = False
else:
    diags += stdout
    succeeded = True
# print('reconfigure completed')

res = stdout.split('\n')
while "wpa_state=COMPLETED" not in res:
    status, stdout, stderr = pscheduler.run_program(wpa_status, timeout=timeout)
    # print(stdout)
    res = stdout.split('\n')
    time.sleep(0.3)

#get the end time for wpa_supplicant to be initialized
end_time = datetime.datetime.now()

# Organize results into json data
results = {
    'succeeded': succeeded,
    'result': {
        'schema': 1,
        'time': pscheduler.timedelta_as_iso8601( end_time - start_time),
        'succeeded': succeeded,
        'final': res
    },
    'error': error,
    'diags': diags }

pscheduler.succeed_json(results)
